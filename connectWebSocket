// connectWebSocket (Retool Query)
try {
   console.log('Starting WebSocket connection...');
  let reconnectAttempts = 0;
  const maxReconnectAttempts = 3;
  const reconnectDelay = 5000;

  // **קריטי:** בדוק כאן, בתחילת ה-Query, אם יש לנו chatId תקני.
  // אם אין, אל תמשיך לנסות לחבר בכלל.
  // זה גם המקום לטפל במעבר מעמוד צ'אט לעמוד שאינו צ'אט.
  if (!chatComponent1.chatId || chatComponent1.chatId.length < 5 || !chatComponent1.userId || !chatComponent1.username) {
      console.warn('connectWebSocket: Not in a chat context (no valid chatId). Attempting to close any existing connection.');
      // אם יש חיבור קיים (אפילו אם הוא "כללי" או לטיקט אחר), סגור אותו כעת.
      if (window.myGlobalWebSocket && window.myGlobalWebSocket.readyState === WebSocket.OPEN) {
          console.warn('connectWebSocket: Closing existing WebSocket connection as not in chat context.');
          window.myGlobalWebSocket.close(1000, 'Left chat context');
          window.myGlobalWebSocket = null;
      } else if (window.myGlobalWebSocket && window.myGlobalWebSocket.readyState !== WebSocket.CLOSED) {
          console.warn(`connectWebSocket: Terminating existing WebSocket connection in state ${window.myGlobalWebSocket.readyState} as not in chat context.`);
          window.myGlobalWebSocket.terminate();
          window.myGlobalWebSocket = null;
      }
      return; // צא מכל ה-Query אם אין נתונים תקניים
  }

  const connect = async () => { // **async**
    // **קריטי:** לפני ניסיון התחברות חדש, ודא שהחיבור הקיים הוא ל-chatId הנכון.
    // אם יש חיבור קיים ל-chatId אחר, סגור אותו.
    // אם אין חיבור, או שהוא לא פתוח, צור חדש.
    if (window.myGlobalWebSocket) {
        // **לוגיקה משופרת:** אם כבר מחובר, בדוק אם זה לאותו צ'אט
        const existingMetadata = window.myGlobalWebSocket.metadata; // אם שמרנו metadata ב-global socket
        if (window.myGlobalWebSocket.readyState === WebSocket.OPEN && existingMetadata && existingMetadata.chat_id === chatComponent1.chatId.value) {
            console.log('connectWebSocket: Already connected to correct chat. Re-sending JOIN_CHAT to confirm presence.');
            // פשוט שלח JOIN_CHAT שוב (השרת יטפל ב-already in chat)
            window.myGlobalWebSocket.send(JSON.stringify({
                chat_id: chatComponent1.chatId,
                created_by: chatComponent1.userId,
                sender_name: chatComponent1.username,
                type: "JOIN_CHAT"
            }));
            return; // צא, אין צורך ליצור חיבור חדש
        } 
        // אם מחובר אבל לטיקט אחר, או לא פתוח
        console.warn(`connectWebSocket: Found existing WebSocket connection (${window.myGlobalWebSocket.readyState}) but not to current chat or not open. Attempting aggressive close/terminate.`);
        
        let socketToClose = window.myGlobalWebSocket;
        window.myGlobalWebSocket = null; // נקה את ההפניה מיד

        if (socketToClose.readyState === WebSocket.OPEN) {
            socketToClose.close(1000, 'Reconnecting for new chat/user (clean close)');
        } else if (socketToClose.readyState === WebSocket.CONNECTING || socketToClose.readyState === WebSocket.CLOSING) {
            console.warn('connectWebSocket: Existing socket in CONNECTING/CLOSING state, terminating aggressively.');
            socketToClose.terminate();
        } else if (socketToClose.readyState === WebSocket.CLOSED) {
            console.log('connectWebSocket: Existing socket is already CLOSED. No action needed.');
        }

        await new Promise(resolve => {
            let timeoutId;
            if (socketToClose.readyState === WebSocket.CLOSED) { resolve(); return; }
            socketToClose.onclose = () => { clearTimeout(timeoutId); resolve(); };
            socketToClose.onerror = (err) => { console.error('connectWebSocket: Error on old socket during close attempt:', err); clearTimeout(timeoutId); resolve(); };
            timeoutId = setTimeout(() => {
                console.warn('connectWebSocket: Timeout waiting for old socket to close. Checking readyState...');
                if (socketToClose.readyState !== WebSocket.CLOSED) { socketToClose.terminate(); }
                resolve();
            }, 750);
        });
        console.log('connectWebSocket: Old WebSocket fully processed (closed/terminated). Proceeding to open new one.');
    }
    const currentSocketInstance = new WebSocket('wss://chat.futureflow.co.il/');
    console.log('WebSocket object created:', currentSocketInstance);

    currentSocketInstance.onopen = function() {
      console.log('WebSocket connection opened!');
      window.myGlobalWebSocket = this; // שומר את האובייקט הגלובלי
      console.log('WebSocket instance saved to window.myGlobalWebSocket:', window.myGlobalWebSocket);

      // ודא שכל הנתונים הנדרשים קיימים לפני שליחת JOIN_CHAT
      if (!chatComponent1.chatId.value || !chatComponent1.userId || !chatComponent1.username) { // **קריטי: גישה ל-.value**
          console.error('connectWebSocket: ERROR - Missing essential data (chatId/userId/username) for JOIN_CHAT. Cannot send JOIN_CHAT.');
          // במקרה של נתונים חסרים, סגור את החיבור הזה כדי שלא יישאר פתוח לריק
          this.close(1008, 'Missing essential data'); // קוד 1008 = Policy Violation
          return; // אל תשלח JOIN_CHAT אם חסר מידע קריטי
      }

      // שלח את chat_id ו-created_by בעת החיבור
      this.send(JSON.stringify({
        chat_id: chatComponent1.chatId.value,
        created_by: chatComponent1.userId,
        sender_name: chatComponent1.username,
        type: "JOIN_CHAT"
      }));
      console.log('JOIN_CHAT message sent successfully.');
      reconnectAttempts = 0;

      // **קריטי:** טיפול בהודעות נכנסות ישירות כאן, בתוך ה-Query
      this.onmessage = (event) => { // השתמש ב-onmessage כאן עבור הודעות כלליות
          try {
              console.log('Query: Raw WebSocket message received:', event.data);
              const newMsg = JSON.parse(event.data);
              console.log('Query: Parsed WebSocket message:', newMsg);

              // **טיפול ב-CHAT_MESSAGE:**
              if (newMsg.type === 'CHAT_MESSAGE') {
                  if (newMsg.sender && newMsg.text && newMsg.timestamp) {
                      const messageToAdd = {
                          // comment_id: `temp-${Date.now()}`,
                          related_to_id: chatComponent1.chatId.value,
                          comment_text: newMsg.text,
                          created_by_name: newMsg.sender,
                          created_by: newMsg.created_by || 'system',
                          created_at: new Date(newMsg.timestamp).toISOString(),
                      };
                      console.log('Query: Message to add to UI:', messageToAdd);

                      const currentMessages = chatComponent1.previousMessages.value;
                      const existingMessages = Array.isArray(currentMessages) ? currentMessages : [];
                      const existingTimestamps = new Set(existingMessages.map((msg) => msg.created_at));

                      let updatedMessages;
                      if (!existingTimestamps.has(messageToAdd.created_at)) {
                          updatedMessages = [...existingMessages, messageToAdd].sort((a, b) => new Date(a.created_at).getTime() - new Date(b.created_at).getTime());
                          console.log('Query: Updated messages array:', updatedMessages);
                      } else {
                          updatedMessages = existingMessages;
                          console.log('Query: Message already exists, skipping update.');
                      }
                      previousMessages.setValue(updatedMessages);
                  }
                  if (newMsg.onlineUsers && Array.isArray(newMsg.onlineUsers)) {
                      onlineUsersList.setValue(newMsg.onlineUsers);
                  }
              }
              // **טיפול ב-PRESENCE_UPDATE:**
              else if (newMsg.type === 'PRESENCE_UPDATE') {
                  if (newMsg.onlineUsers && Array.isArray(newMsg.onlineUsers)) {
                      onlineUsersList.setValue(newMsg.onlineUsers);
                      console.log('Query: Online users updated from PRESENCE_UPDATE:', newMsg.onlineUsers);
                  }
                  if (newMsg.eventType && newMsg.affectedUserId) {
                      console.log('Query: Emitting presence notification event to component.');
                      if(chatComponent1.userId != newMsg.affectedUserId){
                    onPresenceUpdate.trigger(
              {additionalScope: {
                        type: newMsg.eventType,
                        userId: newMsg.affectedUserId,                               
                        userName:newMsg.affectedUserName,
                        chatId: newMsg.chat_id
                      }}
                      );
                  }
                }
              }
              // **חדש:** טיפול ב-HEARTBEAT_PING מהשרת
              else if (newMsg.type === 'HEARTBEAT_PING') {
                  console.log('Client: Received HEARTBEAT_PING, sending HEARTBEAT_PONG.');
                  // שלח PONG בחזרה עם ה-chat_id הנוכחי של הקומפוננטה
                  this.send(JSON.stringify({
                      type: 'HEARTBEAT_PONG',
                      timestamp: Date.now(),
                      currentChatIdAtClient: chatComponent1.chatId // **קריטי:** שלח את ה-chat_id הנוכחי
                  }));
                  return; // טופל, אל תמשיך
              }
              else {
                  console.warn('Query: Unknown WebSocket message type:', newMsg.type, newMsg);
              }
          } catch (e) {
              console.error('Query: Error processing WebSocket message:', e, event.data);
          }
      };


      if (pendingMessage.value) { // משתמש ב-pendingMessage (Store Value)
        console.log('Sending pending message...');
        const pendingMsg = pendingMessage.value;
        this.send(JSON.stringify(pendingMsg));
        pendingMessage.setValue(null);
      }
    };

    currentSocketInstance.onclose = function() {
      console.log('WebSocket connection closed!');
      if (window.myGlobalWebSocket === this) {
          window.myGlobalWebSocket = null;
          console.log('window.myGlobalWebSocket set to null on close.');
      } else {
          console.log('Another WebSocket instance closed, not the current global one.');
      }
      if (reconnectAttempts < maxReconnectAttempts) {
        reconnectAttempts++;
        console.log(`Attempting to reconnect (${reconnectAttempts}/${maxReconnectAttempts})...`);
        setTimeout(connect, reconnectDelay);
      } else {
        console.error('Max reconnect attempts reached. Giving up.');
      }
    };

    currentSocketInstance.onerror = function(error) {
      console.error('WebSocket error occurred:', error);
      if (window.myGlobalWebSocket === this) {
          window.myGlobalWebSocket = null;
      } else {
          console.log('Another WebSocket instance had an error, not the current global one.');
      }
      console.log('webSocketInstance value set to null on error.');
    };
  };

  connect();
} catch (error) {
  console.error('Error in connectWebSocket Query:', error);
  if (window.myGlobalWebSocket) {
    window.myGlobalWebSocket = null;
  }
  console.log('webSocketInstance value set to null in catch block.');
}
