// connectWebSocket (Retool Query)
try {
  console.log('Starting WebSocket connection...');
  let reconnectAttempts = 0;
  const maxReconnectAttempts = 3;
  const reconnectDelay = 5000;

  const connect = async () => { 

    // **חדש (קריטי לסגירה יזומה):** לפני ניסיון התחברות חדש, ודא שאין חיבור קיים ופתוח.
    // אם קיים, סגור אותו קודם. זה קורה אם משתמש עובר מטיקט לטיקט.
     if (window.myGlobalWebSocket) {
        console.warn(`connectWebSocket: Found existing WebSocket connection in state ${window.myGlobalWebSocket.readyState}. Attempting to close/terminate it.`);
        if (window.myGlobalWebSocket.readyState === WebSocket.OPEN || window.myGlobalWebSocket.readyState === WebSocket.CONNECTING) {
            window.myGlobalWebSocket.close(1000, 'Reconnecting for new chat/user');
        } else if (window.myGlobalWebSocket.readyState !== WebSocket.CLOSED) {
            console.warn(`connectWebSocket: Found existing WebSocket connection in state ${window.myGlobalWebSocket.readyState}. Terminating it to clear.`);
            window.myGlobalWebSocket.terminate();
        } else {
            console.log('connectWebSocket: Existing socket is already closed.');
        }
        window.myGlobalWebSocket = null; // נקה את ההפניה

        // **חדש (קריטי):** המתן מעט כדי לתת לחיבור הישן זמן להיסגר
        await new Promise(resolve => setTimeout(resolve, 100)); // המתן 100 מילישניות
        console.log('connectWebSocket: Waited briefly for old connection to close.');
    }

    const currentSocketInstance = new WebSocket('wss://chat.futureflow.co.il/');
    console.log('WebSocket object created:', currentSocketInstance);

    currentSocketInstance.onopen = function() {
      console.log('WebSocket connection opened!');
      window.myGlobalWebSocket = this; // שומר את האובייקט הגלובלי
      console.log('WebSocket instance saved to window.myGlobalWebSocket:', window.myGlobalWebSocket);

      // ודא שכל הנתונים הנדרשים קיימים לפני שליחת JOIN_CHAT
      if (!chatComponent1.chatId || !chatComponent1.userId || !chatComponent1.username) { // **קריטי: גישה ל-.value**
          console.error('connectWebSocket: ERROR - Missing essential data (chatId/userId/username) for JOIN_CHAT. Cannot send JOIN_CHAT.');
          // במקרה של נתונים חסרים, סגור את החיבור הזה כדי שלא יישאר פתוח לריק
          this.close(1008, 'Missing essential data'); // קוד 1008 = Policy Violation
          return; // אל תשלח JOIN_CHAT אם חסר מידע קריטי
      }

      // שלח את chat_id ו-created_by בעת החיבור
      this.send(JSON.stringify({
        chat_id: chatComponent1.chatId,
        created_by: chatComponent1.userId,
        sender_name: chatComponent1.username,
        type: "JOIN_CHAT"
      }));
      console.log('JOIN_CHAT message sent successfully.');
      reconnectAttempts = 0;

      // **קריטי:** טיפול בהודעות נכנסות ישירות כאן, בתוך ה-Query
      this.onmessage = (event) => { // השתמש ב-onmessage כאן עבור הודעות כלליות
          try {
              console.log('Query: Raw WebSocket message received:', event.data);
              const newMsg = JSON.parse(event.data);
              console.log('Query: Parsed WebSocket message:', newMsg);

              // **טיפול ב-CHAT_MESSAGE:**
              if (newMsg.type === 'CHAT_MESSAGE') {
                  if (newMsg.sender && newMsg.text && newMsg.timestamp) {
                      const messageToAdd = {
                          // comment_id: `temp-${Date.now()}`,
                          related_to_id: chatComponent1.chatId,
                          comment_text: newMsg.text,
                          created_by_name: newMsg.sender,
                          created_by: newMsg.created_by || 'system',
                          created_at: new Date(newMsg.timestamp).toISOString(),
                      };
                      console.log('Query: Message to add to UI:', messageToAdd);

                      const currentMessages = chatComponent1.previousMessages.value;
                      const existingMessages = Array.isArray(currentMessages) ? currentMessages : [];
                      const existingTimestamps = new Set(existingMessages.map((msg) => msg.created_at));

                      let updatedMessages;
                      if (!existingTimestamps.has(messageToAdd.created_at)) {
                          updatedMessages = [...existingMessages, messageToAdd].sort((a, b) => new Date(a.created_at).getTime() - new Date(b.created_at).getTime());
                          console.log('Query: Updated messages array:', updatedMessages);
                      } else {
                          updatedMessages = existingMessages;
                          console.log('Query: Message already exists, skipping update.');
                      }
                      previousMessages.setValue(updatedMessages);
                  }
                  if (newMsg.onlineUsers && Array.isArray(newMsg.onlineUsers)) {
                      onlineUsersList.setValue(newMsg.onlineUsers);
                  }
              }
              // **טיפול ב-PRESENCE_UPDATE:**
              else if (newMsg.type === 'PRESENCE_UPDATE') {
                  if (newMsg.onlineUsers && Array.isArray(newMsg.onlineUsers)) {
                      onlineUsersList.setValue(newMsg.onlineUsers);
                      console.log('Query: Online users updated from PRESENCE_UPDATE:', newMsg.onlineUsers);
                  }
                  if (newMsg.eventType && newMsg.affectedUserId) {
                      console.log('Query: Emitting presence notification event to component.');
                      if(chatComponent1.userId != newMsg.affectedUserId){
                    onPresenceUpdate.trigger(
              {additionalScope: {
                          type: newMsg.eventType,
                              userId: newMsg.affectedUserId,                               userName:newMsg.affectedUserName,
                          chatId: newMsg.chat_id
                      }}
                      );
                  }
                }
              }
              // **חדש:** טיפול ב-HEARTBEAT_PING מהשרת
              else if (newMsg.type === 'HEARTBEAT_PING') {
                  console.log('Client: Received HEARTBEAT_PING, sending HEARTBEAT_PONG.');
                  // שלח PONG בחזרה עם ה-chat_id הנוכחי של הקומפוננטה
                  this.send(JSON.stringify({
                      type: 'HEARTBEAT_PONG',
                      timestamp: Date.now(),
                      currentChatIdAtClient: chatComponent1.chatId // **קריטי:** שלח את ה-chat_id הנוכחי
                  }));
                  return; // טופל, אל תמשיך
              }
              else {
                  console.warn('Query: Unknown WebSocket message type:', newMsg.type, newMsg);
              }
          } catch (e) {
              console.error('Query: Error processing WebSocket message:', e, event.data);
          }
      };


      if (pendingMessage.value) { // משתמש ב-pendingMessage (Store Value)
        console.log('Sending pending message...');
        const pendingMsg = pendingMessage.value;
        this.send(JSON.stringify(pendingMsg));
        pendingMessage.setValue(null);
      }
    };

    currentSocketInstance.onclose = function() {
      console.log('WebSocket connection closed!');
      if (window.myGlobalWebSocket === this) {
          window.myGlobalWebSocket = null;
          console.log('window.myGlobalWebSocket set to null on close.');
      } else {
          console.log('Another WebSocket instance closed, not the current global one.');
      }
      if (reconnectAttempts < maxReconnectAttempts) {
        reconnectAttempts++;
        console.log(`Attempting to reconnect (${reconnectAttempts}/${maxReconnectAttempts})...`);
        setTimeout(connect, reconnectDelay);
      } else {
        console.error('Max reconnect attempts reached. Giving up.');
      }
    };

    currentSocketInstance.onerror = function(error) {
      console.error('WebSocket error occurred:', error);
      if (window.myGlobalWebSocket === this) {
          window.myGlobalWebSocket = null;
      } else {
          console.log('Another WebSocket instance had an error, not the current global one.');
      }
      console.log('webSocketInstance value set to null on error.');
    };
  };

  connect();
} catch (error) {
  console.error('Error in connectWebSocket Query:', error);
  if (window.myGlobalWebSocket) {
    window.myGlobalWebSocket = null;
  }
  console.log('webSocketInstance value set to null in catch block.');
}
